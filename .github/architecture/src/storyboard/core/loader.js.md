# `src/storyboard/core/loader.js`

<!--
source: src/storyboard/core/loader.js
category: storyboard
importance: high
-->

> [← Architecture Index](../../../architecture.index.md)

## Goal

The scene loader is the data engine of the storyboard system. It consumes the `virtual:storyboard-data-index` virtual module (generated by the [`storyboardData()`](../vite/data-plugin.js.md) Vite plugin) to load scene, object, and record data by name. It resolves `$global` and `$ref` directives using name-based lookups (e.g., `"jane-doe"` instead of relative file paths) and returns fully merged, flattened data objects.

The loader supports JSONC (JSON with comments) via `jsonc-parser`, provides synchronous record access via `loadRecord()` and `findRecord()`, and detects circular `$ref` chains to prevent infinite loops. All data files are eagerly bundled at build time through the virtual module — no runtime filesystem access occurs.

## Composition

**`loadScene(sceneName)`** — the main entry point. Loads a scene file by name, processes `$global` merges, then resolves all `$ref` objects recursively:

```js
export async function loadScene(sceneName = 'default') {
  let sceneData = loadDataFile(sceneName, 'scenes')

  // 1. Merge $global references into root (scene values win)
  if (Array.isArray(sceneData.$global)) {
    const globalNames = sceneData.$global
    delete sceneData.$global

    let mergedGlobals = {}
    for (const name of globalNames) {
      let globalData = loadDataFile(name)
      globalData = await resolveRefs(globalData)
      mergedGlobals = deepMerge(mergedGlobals, globalData)
    }
    sceneData = deepMerge(mergedGlobals, sceneData)
  }

  // 2. Resolve $ref objects throughout the tree
  sceneData = await resolveRefs(sceneData)
  return sceneData
}
```

`$global` entries are now plain names (e.g., `"navigation"`) instead of relative paths. They are resolved from the data index by searching all types. `$ref` entries also use names and are resolved from the `objects` type first.

**`deepMerge(target, source)`** — deep merges two objects. Source wins on conflicts, arrays are replaced (not concatenated):

```js
export function deepMerge(target, source) {
  const result = { ...target }
  for (const key of Object.keys(source)) {
    if (/* both values are plain objects */) {
      result[key] = deepMerge(targetValue, sourceValue)
    } else {
      result[key] = sourceValue
    }
  }
  return result
}
```

**`loadDataFile(name, type)`** — loads a data file by name and optional type (`"scenes"`, `"objects"`, or `"records"`) from the virtual data index. If no type is given, searches all types. Includes case-insensitive fallback for scene lookups:

```js
function loadDataFile(name, type) {
  if (type && dataIndex[type]?.[name] != null) {
    return parseRaw(dataIndex[type][name])
  }
  // Search all types if no specific type given
  if (!type) {
    for (const t of ['scenes', 'objects', 'records']) {
      if (dataIndex[t]?.[name] != null) return parseRaw(dataIndex[t][name])
    }
  }
  // Case-insensitive fallback for scenes
  // ...
}
```

**`resolveRefs(node, seen)`** — recursively walks the data tree replacing `{ "$ref": "name" }` objects with the referenced file's contents. Tracks visited names in a `Set` for circular reference detection:

```js
if (node.$ref && typeof node.$ref === 'string') {
  const refName = node.$ref
  if (seen.has(refName)) {
    throw new Error(`Circular $ref detected: ${refName}`)
  }
  seen.add(refName)
  const refData = loadDataFile(refName, 'objects')
  return resolveRefs(refData, seen)
}
```

**`sceneExists(sceneName)`** — checks whether a scene file exists in the data index, with case-insensitive fallback:

```js
export function sceneExists(sceneName) {
  if (dataIndex.scenes[sceneName] != null) return true
  const lower = sceneName.toLowerCase()
  for (const key of Object.keys(dataIndex.scenes)) {
    if (key.toLowerCase() === lower) return true
  }
  return false
}
```

**`loadRecord(recordName)`** — synchronously loads a record collection by name. Validates the data is an array:

```js
export function loadRecord(recordName) {
  const raw = dataIndex.records[recordName]
  if (raw == null) throw new Error(`Record not found: ${recordName}`)
  const data = parseRaw(raw)
  if (!Array.isArray(data)) throw new Error(`Record "${recordName}" must be an array`)
  return data
}
```

**`findRecord(recordName, id)`** — finds a single record entry by `id` within a collection. Returns the matched entry or `null`:

```js
export function findRecord(recordName, id) {
  const records = loadRecord(recordName)
  return records.find((entry) => entry.id === id) ?? null
}
```

**`dataIndex`** — imported from the `virtual:storyboard-data-index` virtual module generated by the [`storyboardData()`](../vite/data-plugin.js.md) Vite plugin:

```js
import dataIndex from 'virtual:storyboard-data-index'
```

## Dependencies

- `jsonc-parser` — `parse` function for JSONC support
- `virtual:storyboard-data-index` — Virtual module generated by [`src/storyboard/vite/data-plugin.js`](../vite/data-plugin.js.md) containing all data files keyed by name and type

## Dependents

- [`src/storyboard/context.jsx`](../context.jsx.md) — calls `loadScene()`, `sceneExists()`, `findRecord()`, and `deepMerge()` in the provider
- [`src/storyboard/hooks/useRecord.js`](../hooks/useRecord.js.md) — calls `loadRecord()` and `findRecord()` for record hooks
- [`src/storyboard/index.js`](../index.js.md) — re-exports `loadScene`, `sceneExists`, `loadRecord`, and `findRecord`

## Notes

- Data files are now discovered by suffix (`*.scene.json`, `*.object.json`, `*.record.json`) anywhere in the repo, not by folder location. The [`storyboardData()`](../vite/data-plugin.js.md) Vite plugin handles discovery and builds the virtual module at build time.
- `$ref` and `$global` now use plain names (e.g., `"jane-doe"`) instead of relative paths (e.g., `"../objects/jane-doe"`). Names are resolved from the data index, with `$ref` preferring the `objects` type.
- The `$global` directive is processed before `$ref` resolution, so global objects can themselves contain `$ref` entries that will be resolved.
- Circular `$ref` detection uses a shared `Set` within a single `resolveRefs` call tree. Each `$global` reference is resolved independently (no cross-global cycle detection).
- Scene name lookup includes a case-insensitive fallback for page-scene matching regardless of file name casing.
- `deepMerge` is exported for use by [`src/storyboard/context.jsx`](../context.jsx.md) for record data injection.
